"""# `//ll:attributes.bzl`

Attribute dictionaries for `ll_*` rules.
"""

load("@bazel_skylib//lib:dicts.bzl", "dicts")
load("//ll:providers.bzl", "LlInfo")

DEFAULT_ATTRS = {
    "deps": attr.label_list(
        doc = """The dependencies for this target.

        Every dependency needs to be an `ll_library`.""",
        providers = [LlInfo],
    ),
    "data": attr.label_list(
        doc = """Additional files made available to the sandboxed actions
        executed within this rule. These files are not appended to the default
        line arguments, but are part of the inputs to the actions and may be
        added to command line arguments manually via the `includes`,
        and `compile_flags` (for `ll_binary also `link_flags`) attributes.

        This attribute may be used to make intermediary outputs from non-ll
        targets (e.g. from `rules_cc` or `filegroup`) available to the rule.
        """,
        allow_files = True,
    ),
    "srcs": attr.label_list(
        doc = """Compilable source files for this target.

        Only compilable files and object files
        `[".ll", ".o", ".S", ".c", ".cl", ".cpp"]` are allowed here.

        Headers should be placed in the `hdrs` attribute.
        """,
        allow_files = [".ll", ".o", ".S", ".c", ".cc", ".cl", ".cpp"],
    ),
    "hdrs": attr.label_list(
        doc = """Header files for this target.

        Headers in this attribute will not be exported, i.e. any generated
        include paths are only used for this target and the header files are
        not made available to downstream targets.

        When including header files as `#include "some/path/myheader.h"` their
        include paths need to be specified in the `includes` attribute as well.
        """,
        allow_files = True,
    ),
    "defines": attr.string_list(
        doc = """Additional defines for this target.

        A list of strings `["MYDEFINE_1", "MYDEFINE_2"]` will add
        `-DMYDEFINE_1 -DMYDEFINE_2` to the compile command line.

        Only used for this target.
        """,
    ),
    "includes": attr.string_list(
        doc = """Additional quoted include paths for this target.

        When including a header not via `#include "header.h"`, but via
        `#include "subdir/header.h"`, the include path needs to be added here in
        addition to making the header available in the `hdrs` attribute.

        Only used for this target.
        """,
    ),
    "relative_includes": attr.string_list(
        doc = """Additional quoted include paths, relative to the target
        workspace.

        This attribute is useful if we require custom include prefix stripping,
        but have dynamic paths, such as ones generated by ``bzlmod``. So instead
        of using ``includes = ["external/mydep.someversion/include"]`` we can
        use ``relative_includes = ["include"]``, and the path to the workspace
        will be added automatically.

        Only used for this target.
        """,
    ),
    "angled_includes": attr.string_list(
        doc = """Additional angled include paths for this target.

        Per default all inclusions are quoted includes (via ``-iquote``).
        Paths added here are available as angled includes (via ``-I``).

        Only used for this target.
        """,
    ),
    "relative_angled_includes": attr.string_list(
        doc = """Additional angled include paths, relative to the target
        workspace.

        This attribute is useful if we require custom include prefix stripping,
        but have dynamic paths, such as ones generated by ``bzlmod``. So instead
        of using ``angled_includes = ["external/mydep.someversion/include"]`` we
        can use ``relative_angled_includes = ["include"]``, and the path to the
        workspace will be added automatically.

        Only used for this target.
        """,
    ),
    "compile_flags": attr.string_list(
        doc = """Additional flags for the compiler.

        A list of strings `["-O3", "-std=c++20"]` will be appended to the
        compile command line arguments as `-O3 -std=c++20`.

        Flag pairs like `-Xclang -somearg` need to be split into separate flags
        `["-Xclang", "-somearg"]`.

        Only used for this target.
        """,
    ),
}

HETEROGENEOUS_ATTRS = {
    "heterogeneous_mode": attr.string(
        doc = """Enables compilation of heterogeneous single source files.

        WARNING: VERY EXPERIMENTAL.

        Prefer using this attribute over adding CUDA/HIP flags manually in the
        `"compile_flags"` and `"link_flags"`.

        See <TODO: GUIDE> for a detailed explanation of how this flag changes
        the autogenerated command line arguments/compile passes.

        `"hip_nvidia"` will treat compilable sources as HIP/Nvidia kernels.
        The CUDA toolkit needs to be installed on the execution platform and the
        symlink `/usr/local/cuda -> /usr/local/cuda-MM.m/` must exist.

        `"hip_amd"` will treat compilable sources as HIP/AMD kernels.
        The ROCm/HIP stack does not need to be installed on the execution
        platform. TODO: UNDER CONSTRUCTION. DOES NOT WORK YET.

        `"none"` the default. Does not treat inputs as GPU kernels.
        """,
        default = "none",
        values = ["none", "hip_nvidia", "hip_amd"],
    ),
}

LIBRARY_ATTRS = {
    "aggregate": attr.string(
        doc = """Sets the aggregation mode for compiled outputs in `ll_library`.

        `"static"` invokes the archiver and creates an archive with a `.a`
        extension.
        `"bitcode"` invokes the bitcode linker and creates a bitcode file with a
        `.bc` extension.
        `"none"` will not invoke any aggregator. Instead, loose object files
        will be output by the rule.

        Not used by `ll_binary`, but `ll_library` targets with
        `aggregate = "bitcode"` can be used as `deps` for `ll_binary`.
        """,
        default = "static",
        values = ["static", "bitcode", "none"],
    ),
    "bitcode_link_flags": attr.string_list(
        doc = """Additional flags for the bitcode linker.

        If `aggregate = "bitcode"`, these flags are passed to the bitcode
        linker. The default bitcode linker is `llvm-link`.
        """,
    ),
    "bitcode_libraries": attr.label_list(
        doc = """Bitcode libraries that should always be linked.

        Only used if `aggregate = "bitcode"`.
        """,
        allow_files = [".bc"],
    ),
    "transitive_defines": attr.string_list(
        doc = """Additional transitive defines for this target.

        These defines will be defined by all depending downstream targets.
        """,
    ),
    "transitive_hdrs": attr.label_list(
        doc = """Transitive headers for this target.

        Any transitive headers will be exported (copied) to the build directory.

        Transitive headers are available to depending downstream targets.
        """,
        allow_files = True,
    ),
    "transitive_includes": attr.string_list(
        doc = """Additional transitive include paths for this target.

        Includes in this attribute will be added to the compile command line
        arguments for all downstream targets.
        """,
    ),
    "transitive_relative_includes": attr.string_list(
        doc = """Additional transitive include paths, relative to the original
        target workspace.

        Includes in this attribute will be added to the compile command line
        arguments for all downstream targets.
        """,
    ),
    "transitive_angled_includes": attr.string_list(
        doc = """Additional transitive angled include paths for this target.

        Includes in this attribute will be added to the compile command line
        arguments for all downstream targets.
        """,
    ),
    "transitive_relative_angled_includes": attr.string_list(
        doc = """Additional transitive angled include paths, relative to the
        original target workspace.

        Includes in this attribute will be added to the compile command line
        arguments for all downstream targets.
        """,
    ),
}

BINARY_ATTRS = {
    "libraries": attr.label_list(
        doc = """Additional libraries linked to the final executable.

        Adds these libraries to the command line arguments for the linker.
        """,
        allow_files = True,
    ),
    "link_flags": attr.string_list(
        doc = """Additional flags for the linker.

        For `ll_binary`:
        This is the place for adding library search paths and external link
        targets.

        Assuming you have a library `/some/path/libmylib.a` on your host system,
        you can make `mylib.a` available to the linker by passing
        `["-L/some/path", "-lmylib"]` to this attribute.

        Prefer using the `libraries` attribute for library files already present
        within the bazel build graph.
        """,
    ),
}

BOOTSTRAP_TOOLCHAIN_ATTRS = {
    "c_driver": attr.label(
        doc = "The C compiler driver.",
        executable = True,
        allow_single_file = True,
        cfg = "exec",
        default = "@llvm-project//clang:clang",
    ),
    "cpp_driver": attr.label(
        doc = "The C++ compiler driver.",
        allow_single_file = True,
        executable = True,
        cfg = "exec",
        default = "@llvm-project//clang:clang++",
    ),
    "archiver": attr.label(
        doc = "The archiver.",
        allow_single_file = True,
        executable = True,
        cfg = "exec",
        default = "@llvm-project//llvm:llvm-ar",
    ),
    "linker": attr.label(
        doc = "The linker.",
        allow_single_file = True,
        executable = True,
        cfg = "exec",
        default = "@llvm-project//lld:lld",
    ),
    "builtin_includes": attr.label(
        doc = "Builtin header files. Defaults to @llvm-project//clang:builtin_headers_gen",
        cfg = "target",
        default = "@llvm-project//clang:builtin_headers_gen",
    ),
}

TOOLCHAIN_ATTRS = {
    "bitcode_linker": attr.label(
        doc = """The linker for LLVM bitcode files. While `llvm-ar` is able
        to archive bitcode files into an archive, it cannot link them into
        a single bitcode file. We need `llvm-link` to do this.
        """,
        executable = True,
        cfg = "exec",
        default = "@llvm-project//llvm:llvm-link",
    ),
    "cpp_stdlib": attr.label(
        doc = "The C++ standard library archive.",
        cfg = "target",
        default = "@llvm-project//libcxx:libll_cxx",
        providers = [LlInfo],
    ),
    "cpp_stdhdrs": attr.label(
        doc = "The C++ standard library headers.",
        cfg = "target",
        default = "@llvm-project//libcxx:libcxx_headers",
        allow_files = True,
    ),
    "cpp_abi": attr.label(
        doc = "The C++ ABI library archive.",
        cfg = "target",
        default = "@llvm-project//libcxxabi:libll_cxxabi",
        providers = [LlInfo],
    ),
    "compiler_runtime": attr.label(
        doc = "The compiler runtime.",
        cfg = "target",
        default = "@llvm-project//compiler-rt:libll_compiler-rt",
        providers = [LlInfo],
    ),
    "unwind_library": attr.label(
        doc = "The unwinder library.",
        cfg = "target",
        default = "@llvm-project//libunwind:libll_unwind",
    ),
    "local_crt": attr.label(
        doc = "A filegroup containing the system's local crt1.o, crti.o and crtn.o files.",
        default = "@local_crt//:crt",
    ),
    "clang_tidy": attr.label(
        doc = "The clang-tidy executable.",
        cfg = "exec",
        default = "@llvm-project//clang-tools-extra/clang-tidy:clang-tidy",
        executable = True,
    ),
    "clang_tidy_runner": attr.label(
        doc = "The run-clang-tidy.py wrapper script for clang-tidy. Enables multithreading.",
        cfg = "exec",
        default = "@llvm-project//clang-tools-extra/clang-tidy:run-clang-tidy",
        executable = True,
    ),
    "symbolizer": attr.label(
        doc = "The llvm-symbolizer.",
        cfg = "exec",
        default = "@llvm-project//llvm:llvm-symbolizer",
        executable = True,
    ),
}

HETEROGENEOUS_TOOLCHAIN_ATTRS = {
    "offload_bundler": attr.label(
        doc = """Offload bundler used to bundle code objects for languages
        targeting multiple devices in a single source file, e.g. GPU code.
        """,
        cfg = "exec",
        default = "@llvm-project//clang:clang-offload-bundler",
        executable = True,
    ),
    "machine_code_tool": attr.label(
        doc = "The llvm-mc tool. Used for separarable compilation (CUDA/HIP).",
        cfg = "exec",
        default = "@llvm-project//llvm:llvm-mc",
        executable = True,
    ),
    "cuda_toolkit": attr.label_list(
        doc = """CUDA toolkit files. `rules_ll` will still use `clang` as
        the CUDA device compiler. Building targets that make use of the
        CUDA libraries imply acceptance of their respective licenses.
        """,
        default = [
            "@cuda_cudart//:contents",
            "@cuda_nvcc//:contents",
            "@cuda_nvprof//:contents",
            "@libcurand//:contents",
        ],
        cfg = "target",
    ),
    "hip_libraries": attr.label_list(
        doc = """HIP library files. `rules_ll` will use `clang` as the
        device compiler. Building targets that make use of the HIP toolkit
        implies acceptance of its license.

        Using HIP for AMD devices implies the use of the ROCm stack and the
        acceptance of its licenses.

        Using HIP for Nvidia devices implies use of the CUDA toolkit and the
        acceptance of its licenses.
        """,
        default = [
            "@hip//:headers",
            "@hipamd//:headers",
        ],
        cfg = "target",
    ),
}

LL_BOOTSTRAP_TOOLCHAIN_ATTRS = BOOTSTRAP_TOOLCHAIN_ATTRS
LL_TOOLCHAIN_ATTRS = dicts.add(BOOTSTRAP_TOOLCHAIN_ATTRS, TOOLCHAIN_ATTRS)
LL_HETEROGENEOUS_TOOLCHAIN_ATTRS = dicts.add(
    BOOTSTRAP_TOOLCHAIN_ATTRS,
    TOOLCHAIN_ATTRS,
    HETEROGENEOUS_TOOLCHAIN_ATTRS,
)

LL_BOOTSTRAP_LIBRARY_ATTRS = dicts.add(DEFAULT_ATTRS, LIBRARY_ATTRS)
LL_LIBRARY_ATTRS = dicts.add(DEFAULT_ATTRS, HETEROGENEOUS_ATTRS, LIBRARY_ATTRS)
LL_BINARY_ATTRS = dicts.add(DEFAULT_ATTRS, HETEROGENEOUS_ATTRS, BINARY_ATTRS)
